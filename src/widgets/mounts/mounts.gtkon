VBox $Mounts.Widget using=Gtk border-width=5
		using:Radare="Radare"
		using:Gdk="Gdk"
		using:Listview="Listview" {
	HBox !expand spacing=3 {
		ComboBox !expand $fstype text;
		Entry $mountpoint;
		Entry $offset;
		Button !expand label=mount clicked=do_mount;
//		Button !expand label=umount clicked=do_umount;
	}
	VPaned position=200 {
		Listview:Widget $listview;
		ScrolledWindow $scroll add2 {
			IconView $dirs button_release_event=rclick button_press_event=dclick;
		}
	}
-{
	public RFS *fs = null;
	public ListStore model;
	private string path;

	public Widget() {
		fstype.append_text ("cpio");
		fstype.append_text ("ext2");
		fstype.append_text ("fat");
		fstype.append_text ("fb");
		fstype.append_text ("hfs");
		fstype.append_text ("hfsplus");
		fstype.append_text ("iso9660");
		fstype.append_text ("jfs");
		fstype.append_text ("minix");
		fstype.append_text ("ntfs");
		fstype.append_text ("posix");
		fstype.append_text ("reiserfs");
		fstype.append_text ("sfs");
		fstype.append_text ("tar");
		fstype.append_text ("udf");
		fstype.append_text ("ufs");
		fstype.append_text ("xfs");
		fstype.set_active (0);
		mountpoint.text = "/";
		offset.text = "0";
		listview.set_actions ("Show", "Umount");
		listview.menu_handler.connect ((action, row) => {
			if (fs == null || row == null) {
				stderr.printf ("Oops: fs is null\n");
				return;
			}
			switch (action) {
			case "Show":
				path = row.name;
				update_icons ();
				break;
			case "Umount":
				print (@"Umount $(row.name)\n");
				do_umount (row.name);
				break;
			}
		});
		model = new ListStore (3, typeof (string), typeof (Gdk.Pixbuf), typeof (RFSFile));
		dirs.model = (model);
		dirs.set_item_width (100);
		dirs.set_columns (0);
		dirs.set_orientation (Orientation.VERTICAL);
		dirs.set_text_column (0);
		dirs.set_pixbuf_column (1);
	}

	public void do_mount () {
		void *p = fs->mount (fstype.get_active_text (), mountpoint.text, uint64.parse (offset.text));
		if (p == null) {
			// TODO: how to call gc.show_error() ?
			stderr.printf ("Cannot mount\n");
		} else {
			update_list ();
		}
	}

	public void update_list () {
		listview.clear ();
		foreach (var root in fs->roots) {
			//print (@"MOUNT ($(root.delta)) ($(root.path))\n");
			listview.add_row (root.delta, root.path);
		}
	}

	public void do_umount (string str) {
		fs->umount (str);
		update_list ();
	}

	public void update_icons () {
		TreeIter iter;
		RList<RFSFile> ds;

		chop_path ();
		ds = fs->dir (path);
		if (ds != null) {
			if (ds.length () > 0) {
				model.clear ();
				foreach (var file in ds) {
					var pbuf = dirs.render_icon (
							(file.type == 'd')?Stock.OPEN:Stock.FILE,
							IconSize.LARGE_TOOLBAR, null);
					model.append (out iter);
					model.set (iter, 0, file.name, 1, pbuf, 2, file);
				}
			} else print (@"Directory $(path) is empty!\n");
		}
	}

	private bool rclick (Gtk.Widget _w, Gdk.EventButton eb) {
		RFSFile *item = get_item ();
		if (eb.button != 3)
			return false;
		var menu = new Menu();

		var imi = new ImageMenuItem.with_label ("Back");
		imi.activate.connect ((x)=> {
				path += "/..";
				update_icons ();
				});
		menu.append (imi);

		if (item != null) {
			if (item->type == 'd') {
				imi = new ImageMenuItem.with_label ("Open");
				imi.activate.connect ((x)=> {
						if (item == null || item->type != 'd')
							return;
						path += "/"+item->name;
						update_icons ();
						});
				menu.append (imi);
			} else {
				imi = new ImageMenuItem.with_label ("Dump to file");
				imi.activate.connect ((x)=> { dump_file (item->name); });
				menu.append (imi);

			}
			imi = new ImageMenuItem.with_label ("Properties");
			imi.activate.connect ((x)=> { properties_menu (item); });
			menu.append (imi);
		}

		menu.show_all ();
		menu.popup (null, null, null, 0, 0);
		return false;
	}

	public bool dclick (Gtk.Widget _w , Gdk.EventButton eb) {
		switch (eb.type) {
			case EventType.@2BUTTON_PRESS:
				RFSFile *item = get_item ();
				if (item == null || item->type != 'd')
					return false;
				path += "/"+item->name;
				update_icons ();
				return true; // does not pass the event to the rest of widgets
		}
		return false;
	}

	public RFSFile *get_item () {
		TreeIter iter;
		RFSFile *file = null;
		GLib.List<unowned Gtk.TreePath> list = dirs.get_selected_items ();

		if (list == null || list.length () == 0)
			return file;
		var model = dirs.get_model ();
		if (model.get_iter (out iter, (TreePath)list.data))
			model.get (iter, 2, out file);
		return file;
	}

	public void chop_path () {
		try {
			path += "/";
			Regex reg1 = new Regex ("/[^/]*/\\.\\./");
			path = reg1.replace (path, path.length, 0, "/");
			Regex reg2 = new Regex ("/./");
			path = reg2.replace (path, path.length, 0, "/");
			Regex reg3 = new Regex ("//");
			path = reg3 .replace (path, path.length, 0, "/");
			Regex reg4 = new Regex ("/$");
			path = reg4.replace (path, path.length, 0, "");
			if (path == "") {
				path = "/";
			}
		} catch (RegexError e) {
			stderr.printf ("Error at chop_path\n");
		}
	}

	public void dump_file (string name) {
		RFSFile file = fs->open (path+"/"+name);
		fs->read (file, 0, (int) file.size);
		try {
			// null parent ??
			var fcd = new FileChooserDialog ("Dump File", null, FileChooserAction.SAVE,
					"gtk-cancel", 0, "gtk-ok", 1);
			string? ret = null;
			if (fcd.run () == 1) {
				ret = fcd.get_filename ();
				FileUtils.set_contents (ret, (string) file.data, file.size);
			}
			fcd.hide ();
			fcd.destroy ();
			fcd = null;
		} catch (FileError e) {
			stderr.printf ("Error at dump_file: %s\n", e.message);
		}
		fs->close (file);
	}

	// Move out into a separate widget??
	// FIXME: Why item doesnt fill all gaps ??
	public void properties_menu (RFSFile* item) {
		if (item != null) {
			stdout.printf ("Name: %s\nType: %c\n",
					item->name, item->type);
			var wi = new Gtk.Window ();
			wi.title = @"$(item->name) properties";
			wi.set_default_size (400, 400);

			var hbox = new HBox (false, 0);
			var vbox = new VBox (false, 0);
			var pbuf = this.render_icon (
					(item->type == 'd')?Stock.OPEN:Stock.FILE,
					IconSize.LARGE_TOOLBAR, null);
			hbox.pack_start (new Gtk.Image.from_pixbuf (pbuf), true, true, 0);
			vbox.pack_start (new Label (@"Name: $(item->name)"), true, true, 0);
			vbox.pack_start (new Label (@"Path: $(item->path)"), true, true, 0);
			vbox.pack_start (new Label (@"Size: $(item->size)"), true, true, 0);
			vbox.pack_start (new Label (@"Time: $(item->time)"), true, true, 0);
			vbox.pack_start (new Label (@"Offset: $(item->off)"), true, true, 0);
			hbox.pack_start (vbox, true, true, 0);

			wi.add (hbox);
			wi.show_all ();
		}
	}

}-
}
